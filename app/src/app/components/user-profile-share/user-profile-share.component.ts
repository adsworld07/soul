import { Component, Input, OnInit ,ElementRef, ViewChild } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { UserService } from '../../services/user.service';
import { userDetails } from '../../models/userDetails.model.client';
import { ResumeUploadService } from '../../services/resume-upload.service';
import { JobPostingService } from '../../services/job-posting.service';
import { Meta, Title } from '@angular/platform-browser';
// import { faGithub, faLinkedin, faFacebook, faTwitter } from '@fortawesome/free-brands-svg-icons';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import { ContactDialogComponent } from '../contact-dialog/contact-dialog.component';
@Component({
  selector: 'app-user-profile-share',
  templateUrl: './user-profile-share.component.html',
  styleUrls: ['./user-profile-share.component.css']
})
export class UserProfileShareComponent implements OnInit {
  @Input() feature?: string;
  
  userId!: string;
  user: userDetails['user'] | undefined;
  experiences: userDetails['experiences'] = [];
  education: userDetails['education'] = [];
  skills: userDetails['skill'] = [];
  projects: userDetails['project'] = [];
  resume:any[] = [];
  jobApplication: any;
  userData:any ;
  jobId!: string;
  errorMessage!: string;
  profilePicUrl!: string;
  profilePicExist!: boolean;
 
  viewCount = 0;
  // faGithub = faGithub;
  // faLinkedin = faLinkedin;
  // faFacebook = faFacebook;
  // faTwitter = faTwitter;
  constructor(
    private route: ActivatedRoute,
    private userService: UserService,
    private resumeUploadService: ResumeUploadService,
    private jobPosting: JobPostingService,
    private meta: Meta,
    private title: Title
  ) {}
  @ViewChild('profileContent') profileContent!: ElementRef;
  @ViewChild('resumeSection') resumeSection!: ElementRef;
  @ViewChild('pdfContent', { static: false }) pdfContent!: ElementRef;
  isExporting: boolean = false;
  isPdfExport: boolean = false;

  private readonly companyLogo = '../../../assets/hiyrnow_logo1.png ';
  private readonly footerText = 'Resume generated by HiyrNow and verified by HiyrNow';



  @ViewChild(ContactDialogComponent) contactDialogComponent!: ContactDialogComponent;

  openContactDialog() {
    if (this.contactDialogComponent) {
      this.contactDialogComponent.userData = this.userData;
      this.contactDialogComponent.open();
    }
  }
  handleImageError(event: any) {
    this.profilePicExist = false;
  }

 

  async exportProfileAsPDF() {
    if (!this.userData?.user?.firstName || !this.userData?.user?.lastName) {
      console.error('User name not available');
      return;
    }

    this.isExporting = true;
    this.isPdfExport = true; // Set flag to true before generating PDF
    console.log("DSCDSVCDFSVDFVFDV")
    try {
      // Wait for Angular change detection to update the view
      await new Promise(resolve => setTimeout(resolve, 100));
      
      const content = this.profileContent.nativeElement;
      const pdf = new jsPDF('p', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();

      const canvas = await html2canvas(content, {
        scale: 2,
        useCORS: true,
        logging: false,
        allowTaint: true,
        backgroundColor: '#f9fafb'
      });

      const imgWidth = pageWidth;
      const imgHeight = (canvas.height * imgWidth) / canvas.width;
      const imgData = canvas.toDataURL('image/png');

      // Calculate number of pages needed
      const pageCount = Math.ceil(imgHeight / pageHeight);
      let remainingHeight = imgHeight;
      let currentPosition = 0;

      // Add content pages
      for (let i = 0; i < pageCount; i++) {
        if (i > 0) {
          pdf.addPage();
        }

        pdf.addImage(
          imgData,
          'PNG',
          0,
          currentPosition,
          imgWidth,
          imgHeight
        );

        remainingHeight -= pageHeight;
        currentPosition -= pageHeight;
      }

      // Add branding elements to all pages
      await this.addBrandingToPDF(pdf, pageCount);

      const firstName = this.userData.user.firstName.toLowerCase();
      const lastName = this.userData.user.lastName.toLowerCase();
      const filename = `${firstName}_${lastName}_hiyrnow_profile.pdf`;

      pdf.save(filename);
    } catch (error) {
      console.error('Error generating PDF:', error);
    } finally {
      this.isExporting = false;
      this.isPdfExport = false; // Reset flag after PDF generation
    }
  }
  private async addBrandingToPDF(pdf: jsPDF, pageCount: number) {
    const logoWidth = 30; // Logo width in mm
    const logoHeight = 10; // Logo height in mm
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
  
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);
  
      // Footer Y position
      const footerY = pageHeight - 15; // 15mm from bottom
  
      // ✅ Add logo to bottom-right corner
      pdf.addImage(
        this.companyLogo,
        'PNG',
        pageWidth - logoWidth - 10, // 10mm from the right edge
        footerY,
        logoWidth,
        logoHeight
      );
  
      // ✅ Add footer text (center-aligned)
      pdf.setFontSize(10);
      pdf.setTextColor(128, 128, 128); // Gray color
      pdf.text(
        this.footerText,
        pageWidth / 2,
        pageHeight - 5,
        { align: 'center' }
      );
  
      // ✅ Add page numbers (center-aligned above footer text)
      pdf.text(
        `Page ${i} of ${pageCount}`,
        pageWidth / 2,
        pageHeight - 10,
        { align: 'center' }
      );
    }
  }
  
  ngOnInit(): void {
    this.route.paramMap.subscribe(params => {
      this.userId = params.get('userId')!;
      this.fetchUserDetails();
      this.loadProfilePic(this.userId);
      this.jobId = this.route.snapshot.paramMap.get('jobId') || ''; // Provide fallback for null
      this.userId = this.route.snapshot.paramMap.get('userId') || ''; // Provide fallback for null
  
      this.incrementViewCount();
      if (this.jobId && this.userId) {
        this.getJobApplication();
      } else {
        this.errorMessage = 'Job ID or User ID is missing.';
      }
    });
  }
  incrementViewCount() {
    // Implement view count increment logic
    this.viewCount++;
  }
  loadProfilePic(userId: string): void {
    this.userService.getProfilePic(userId).subscribe({
      next: (data: Blob) => {
        if (data && data.size > 0) {  // Check if we received valid data
          const reader = new FileReader();
          reader.onload = () => {
            this.profilePicUrl = reader.result as string;
            this.profilePicExist = true;
          };
          reader.readAsDataURL(data);
        } else {
          this.setDefaultProfilePic();
        }
      },
      error: (error) => {
        console.error('Error fetching profile picture:', error);
        this.setDefaultProfilePic();
      }
    });
  }
  
  private setDefaultProfilePic(): void {
    // You can use a default image URL or a data URL of a default avatar
    this.profilePicUrl = '../../../assets/defaultUser.jpg'; 
    this.profilePicExist = false;
  }
  getJobApplication(): void {
    this.jobPosting.getJobApplicationByJobIdAndUserId(this.jobId, this.userId)
      .subscribe(
        (data) => {
          this.jobApplication = data;
        },
        (error) => {
          this.errorMessage = 'Error fetching job application: ' + error.message;
        }
      );
  }

  fetchUserDetails(): void {
    
    this.userService.getUserResume(this.userId).subscribe(
      (response: any[]) => {
        if (response.length > 0) {
          const latestFile = response[response.length - 1];
          this.resume = [{
            filename: latestFile.filename,
            originalname: latestFile.originalname,
            contentType: latestFile.contentType
          }];
        console.log("resume:",this.resume)
          // this.filesExist = true;
        } else {
          this.resume = [];
          // this.filesExist = false;
        }
      },
      error => {
        console.error('Error fetching file names:', error);
      }
    );
  
    this.userService.getUserDetails(this.userId, this.feature).subscribe(
      (response: any) => {
        if (response.status === 'success' && response.data) {
          console.log('Response:', response);
    
          this.userData = response.data; // Extract nested data
          this.user = this.userData.user;
          this.experiences = this.userData.experiences || [];
          this.education = this.userData.education || [];
          this.skills = this.userData.skill || [];
          this.projects = this.userData.project || [];
    
          console.log('User:', this.skills);

          if (this.user?.firstName && this.user?.lastName) {
            const fullName = `${this.user.firstName} ${this.user.lastName}`;
            this.title.setTitle(`${fullName} - Profile | HiyrNow`);
            
            this.meta.updateTag({ name: 'description', content: `View ${fullName}'s professional profile on HiyrNow` });
            this.meta.updateTag({ property: 'og:title', content: `${fullName} - Professional Profile` });
            this.meta.updateTag({ property: 'og:description', content: `View ${fullName}'s professional profile on HiyrNow` });
            this.meta.updateTag({ property: 'og:type', content: 'profile' });
            
            if (this.user.tagline) {
              this.meta.updateTag({ name: 'profile:profession', content: this.user.tagline });
            }
          }
        } else {
          console.warn('Unexpected response structure:', response);
        }
      },
      (error: any) => {
        console.error('Error fetching user details:', error);
      }
    );
    
  
  }
  parseInt(value: string): number {
    return parseInt(value);
  }

  downloadPdf(filename: string, contentType: string ,) {
    this.userService.downloadPDF(filename ,this.userId).subscribe(
      (res: Blob) => {
        const file = new Blob([res], { type: contentType });
        const fileURL = URL.createObjectURL(file);
        window.open(fileURL);
      },
      error => {
        console.error('Error downloading PDF:', error);
      }
    );
  }
  // getSocialIcon(socialType: string) {
  //   switch (socialType.toLowerCase()) {
  //     case 'github': return this.faGithub;
  //     case 'linkedin': return this.faLinkedin;
  //     case 'facebook': return this.faFacebook;
  //     case 'twitter': return this.faTwitter;
  //     default: return null;
  //   }
  // }
  calculateMatchScore(): number {
    // Calculate match score based on required skills vs user skills
    // This is a placeholder implementation
    const requiredSkills = ['JavaScript', 'React', 'Node.js'];
    const userSkills = this.userData?.skill?.map((s: any) => s.skillName) || [];
    const matchingSkills = requiredSkills.filter(skill => 
      userSkills.includes(skill)
    );
    return Math.round((matchingSkills.length / requiredSkills.length) * 100);
  }

  getTopSkills() {
    return this.userData?.skill
      ?.sort((a: any, b: any) => parseInt(b.skillLevel) - parseInt(a.skillLevel))
      .slice(0, 5) || [];
  }

  calculateDuration(exp: any): string {
    const start = new Date(exp.startDate.year, this.getMonthNumber(exp.startDate.month));
    const end = exp.ongoingStatus === 'true' 
      ? new Date() 
      : new Date(exp.endDate.year, this.getMonthNumber(exp.endDate.month));
    
    const months = (end.getFullYear() - start.getFullYear()) * 12 + 
                  (end.getMonth() - start.getMonth());
    
    const years = Math.floor(months / 12);
    const remainingMonths = months % 12;
    
    if (years === 0) return `${remainingMonths} mos`;
    if (remainingMonths === 0) return `${years} yr${years > 1 ? 's' : ''}`;
    return `${years} yr${years > 1 ? 's' : ''} ${remainingMonths} mos`;
  }

  getMonthNumber(month: string): number {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return months.indexOf(month);
  }

  getYearsOfExperience(skillName: string): number {
    // Calculate years of experience for a skill based on work history
    const relevantExperience = this.userData.experiences?.filter((exp: any) =>
      exp.stacks?.includes(skillName)
    );
    
    let totalMonths = 0;
    relevantExperience?.forEach((exp: any) => {
      const duration = this.calculateDuration(exp);
      const match = duration.match(/(\d+)\s*yr/);
      if (match) totalMonths += parseInt(match[1]) * 12;
    });
    
    return Math.round(totalMonths / 12);
  }

  getProjectCount(skillName: string): number {
    return this.userData.project?.filter((proj: any) =>
      proj.description.toLowerCase().includes(skillName.toLowerCase())
    ).length || 0;
  }

  getProjectTechnologies(project: any): string[] {
    // Extract technologies from project description
    // This is a simple implementation - you might want to enhance this
    const techKeywords = ['React', 'Angular', 'Vue', 'Node.js', 'Python', 'Java', 'TypeScript'];
    return techKeywords.filter(tech => 
      project.description.toLowerCase().includes(tech.toLowerCase())
    );
  }

  async downloadPDF() {
    this.isExporting = true;

    try {
      // Wait for next render cycle to ensure element is available
      await new Promise(resolve => setTimeout(resolve, 100));

      const element = this.pdfContent?.nativeElement;
      
      if (!element) {
        throw new Error('PDF content element not found');
      }

      // Configure html2canvas options for better quality
      const canvas = await html2canvas(element, {
        scale: 2, // Higher scale for better quality
        useCORS: true, // Enable CORS for images
        logging: false, // Disable logging
        windowWidth: element.scrollWidth,
        windowHeight: element.scrollHeight
      });

      const imgData = canvas.toDataURL('image/png');
      
      // Create PDF with A4 dimensions
      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4'
      });

      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = pdf.internal.pageSize.getHeight();
      
      // Calculate dimensions while maintaining aspect ratio
      const imgWidth = canvas.width;
      const imgHeight = canvas.height;
      const ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight);
      
      const finalWidth = imgWidth * ratio;
      const finalHeight = imgHeight * ratio;
      
      // Center the image on the page
      const x = (pdfWidth - finalWidth) / 2;
      const y = 0;

      pdf.addImage(imgData, 'PNG', x, y, finalWidth, finalHeight);
      pdf.save(`profile_${new Date().getTime()}.pdf`);

    } catch (error) {
      console.error('Error generating PDF:', error);
      // Handle error appropriately (show user feedback)
    } finally {
      this.isExporting = false;
    }
  }

  shareProfile() {
    if (navigator.share) {
      navigator.share({
        title: `${this.userData.user.firstName}'s Profile`,
        text: `Check out ${this.userData.user.firstName}'s professional profile`,
        url: window.location.href
      });
    } else {
      // Fallback - copy to clipboard
      navigator.clipboard.writeText(window.location.href);
      // Show toast notification
    }
  }
}
